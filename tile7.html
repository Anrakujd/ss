<html>

<head> 
<meta charset="utf-8">
<meta name="Deskripsi" content="Website eksperimen matematika bebas diakses oleh guru dan siswa untuk membantu memahami matematika di sekolah">
<meta name="Keywords" content="matematika, eksperimen, praktikum online, webbase praktikum, matematika online, pengubinan, tiling, tile, gasing">
<meta name="author" content="Djukarna">
<title>Geometri</title>
<link rel="stylesheet" href="stylesheets/main.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<script type="text/javascript" src="js/processing.js"></script>
</head>

<header>
	<div class="container">
	<h1> KUBUS ILUMINASI (Polyrhomb) </h1>
		<nav id="navi2">
			<ul>
				<li><a href="index.html"><i class="fa fa-home" aria-hidden="true"></i> <b>Home</b></a></li>
				<li><a href="AnimasiFisika.html"><i class="fa fa-truck" aria-hidden="true"></i> <b>Fisika</b></a></li>
				<li><a href="AnimasiKimia.html"><i class="fa fa-thermometer-half" aria-hidden="true"></i> <b>Kimia</b></a></li>
				<li><a href="AnimasiMatematika.html"><i class="fa fa-bolt" aria-hidden="true"></i> <b>Matematika</b></a></li>
				<li><a href="TeknikMesin.html"><i class="fa fa-sun-o" aria-hidden="true"></i> <b>Mesin</b></a></li>
				<li><a href="tutorial.html"><i class="fa fa-video-camera" aria-hidden="true"></i> <b>Tutorial</b></a></li>
				<li><a href="games.html"><i class="fa fa-snowflake-o" aria-hidden="true"></i> <b>Games</b></a></li>
				<li><a href="about.html"><i class="fa fa-male" aria-hidden="true"></i> <b>About</b></a></li>
			</ul>
		</nav>
	</div>
</header>

<body>

<section id="kotaks">
	<div class="container">
		<div class="kotak1">
		<ul>
			<li><i class="fa fa-square-o" aria-hidden="true"></i><b> Geometri </b>
				<ul>
					<li><a href="tile1.html">Pengubinan Segitiga Sama Sisi (Polyamonds)</a></li>
					<li><a href="tile2.html">Pengubinan Persegi (Polyominos)</a></li>
					<li><a href="tile3.html">Pengubinan Polyamonds & Polyominos </a></li>
					<li><a href="tile4.html">Tangram</a></li>
					<li><a href="tile5.html">Puzzle Two and Half</a></li>
					<li><a href="tile6.html">Puzzle Angka Satu</a></li>
					<li><a href="tile7.html">Kubus Iluminasi (Polyrhomb)</a></li>
					<li><a href="tile8.html">Heptomino</a></li>
					<li><a href="tile9.html">Pentomino</a></li>
					<li><a href="tile10.html">Menara Hanoi</a></li>
				</ul>
			</li>
			<li> <b>Didukung Oleh :</b> 
			     <ul>
				 <a href="http:www.stkipsurya.ac.id" target="_blank"><img src="image/logo.jpg"></img></a>
				 </ul>
			</li>
		</ul>
		</div>
<div class="kotak2">
<h1> Kubus Iluminasi (Polyrhomb)</h1>
<p>Buat Jejeran Kubus !, klik kiri untuk menggeser & klik kanan untuk memutar </p>
<script type="text/processing" >
ArrayList<Node> nodes = new ArrayList();

final int h = 50;
final int DRAG_NONE = 0; 
final int DRAG_1 = 1;
final int DRAG_2 = 2;
final int DRAG_3 = 3;
final int DRAG_4 = 4;

int dragging = DRAG_NONE; 

final int EDIT = 0; // dragging 
final int RUN  = 1; // run the result
int state = EDIT;

final int UNDEFINED = -1; 
int draggingAnExistingRectClass = UNDEFINED; 

void setup() {
  size(1000, 700);
} 

void draw() {
  background(0,255,255);
  
  for (int i = 0; i < nodes.size ()-1; i++) { 
    Node currentNode = nodes.get(i);
    currentNode.display();
  }
  
  if (nodes.size()>0) {
    Node currentNode = nodes.get(nodes.size()-1);
    currentNode.display();
  }
  
  fill(255);
  rect(10, 50, 70, 400);
  
  stroke(0);
  strokeWeight(1);
  fill(0, 0, 255);
  beginShape();
    vertex(45, 120-sqrt(0.75*h*h));
    vertex(45+0.5*h, 120);
    vertex(45, 120+sqrt(0.75*h*h));
    vertex(45-0.5*h,120);
  endShape(CLOSE);
  
  fill(0, 255, 0);
  beginShape();
    vertex(45, 250-sqrt(0.75*h*h));
    vertex(45+0.5*h, 250);
    vertex(45, 250+sqrt(0.75*h*h));
    vertex(45-0.5*h,250);
  endShape(CLOSE);
  
 fill(255, 0, 0);
  beginShape();
    vertex(45, 380-sqrt(0.75*h*h));
    vertex(45+0.5*h, 380);
    vertex(45, 380+sqrt(0.75*h*h));
    vertex(45-0.5*h,380);
  endShape(CLOSE);
  
   if (dragging==DRAG_1) {
    // dragging sign (tupat1)
    stroke(0);
    strokeWeight(1);
    fill(0, 0, 255);
    beginShape();
      vertex(mouseX, mouseY-sqrt(0.75*h*h));
      vertex(mouseX+0.5*h, mouseY);
      vertex(mouseX, mouseY+sqrt(0.75*h*h));
      vertex(mouseX-0.5*h,mouseY);
    endShape(CLOSE);
    } 
    else if (dragging==DRAG_2) {
    // dragging sign (tupat2)
    stroke(0);
    strokeWeight(1);
    fill(0, 255,0);
    beginShape();
      vertex(mouseX, mouseY-sqrt(0.75*h*h));
      vertex(mouseX+0.5*h, mouseY);
      vertex(mouseX, mouseY+sqrt(0.75*h*h));
      vertex(mouseX-0.5*h,mouseY);
    endShape(CLOSE);
    } 
    else if (dragging==DRAG_3) {
    // dragging sign (tupat3)
    stroke(0);
    strokeWeight(1);
    fill(255, 0, 0);
    beginShape();
      vertex(mouseX, mouseY-sqrt(0.75*h*h));
      vertex(mouseX+0.5*h, mouseY);
      vertex(mouseX, mouseY+sqrt(0.75*h*h));
      vertex(mouseX-0.5*h,mouseY);
    endShape(CLOSE);
    } 
    else if (draggingAnExistingRectClass!=UNDEFINED) {
    // menggeser bagunan yang sudah ada
    Node RectClass = nodes.get(draggingAnExistingRectClass);
    RectClass.incrementXY( mouseX-pmouseX, mouseY-pmouseY );
  }
}

void mousePressed() {
     draggingAnExistingRectClass=UNDEFINED; // reset 
    if (dist(mouseX, mouseY, 45, 120)<20) {
      dragging=DRAG_1;
      return;
      } 
      else if (dist(mouseX, mouseY, 45, 250)<20 ) {
      dragging=DRAG_2;
      return;
      } 
      else if (dist(mouseX, mouseY, 45, 380)<20) {
      dragging=DRAG_3;
      return;
      } 
      else {
      for (int i = 0; i < nodes.size (); i++) { 
        Node RectClass = nodes.get(i);
          if (RectClass.over()) {
             draggingAnExistingRectClass = i; 
              return;        
             }
        }
      }    
}

void mouseReleased() {
      if (dragging==DRAG_1) {
      dragging = DRAG_NONE; 
      nodes.add(new Tupat1(mouseX, mouseY,h));
      } 
      else if (dragging==DRAG_2) {
      dragging = DRAG_NONE; // reset
      nodes.add(new Tupat2(mouseX, mouseY,h));
      } 
      else if (dragging==DRAG_3) {
      dragging = DRAG_NONE; // reset 
      nodes.add(new Tupat3(mouseX, mouseY,h));
      } 
    draggingAnExistingRectClass=UNDEFINED; // reset
}

interface Node {
  void display();
  void incrementXY(float x_, float y_);
  PVector getPos();
  boolean over();
}

// menghapus broooo
void keyPressed() {
  // only in state EDIT: 
  if (state==EDIT) {
    if (key==' ') {
      state=RUN;
      frameRate(2);
    } else if (key==DELETE) {
      if (nodes.size()>0) { 
        nodes.remove(nodes.size()-1);
      }
    }
  }
}

class Tupat1 implements Node {  
  float x1;
  float y1;
  float h1;
  float angle1 = 0;
  Tupat1(float x0, float y0, float h0) {
    x1 = x0; 
    y1 = y0;
    h1 = h0;
  }
  void display() {
    if (dist(mouseX, mouseY, x1, y1) < h1/2) {
      if (mousePressed && mouseButton==LEFT) {
        fill(255, 255, 0);
        x1 = mouseX;
        y1 = mouseY;
      } else if (mousePressed && mouseButton==RIGHT) {
        fill(255, 255, 0);
        angle1 = angle1 + 30;
       for(int i = 0;  i <= 100000000; i+=1){
		i= i + 1;}
        return;
      } else {
        fill(255, 0, 255);
      }
    } else {
      fill(0, 0, 255);
    }
    pushMatrix();
    translate(x1, y1);
    rotate(radians(angle1));
    beginShape();
    vertex(0, -sqrt(0.75*h1*h1));
    vertex(+0.5*h1, 0);
    vertex(0, sqrt(0.75*h1*h1));
    vertex(-0.5*h1,0);
    endShape(CLOSE);
    popMatrix();
  }
  
  void setXY(float x_, float y_) {
    x1=x_;
    y1=y_;
  }
  void incrementXY(float x_, float y_) {
    x1+=x_;
    y1+=y_;
  }
  PVector getPos() {
    return new PVector(x1+h1/2, y1+h1/2);
  }
  boolean over() {
    return mouseX>x1 && mouseX<x1+h1 && mouseY>y1 && mouseY<y1+h1;
  }
} 

class Tupat2 implements Node {  
  float x2;
  float y2;
  float h2;
  float angle2 = 0;
  Tupat2(float x0, float y0, float h0) {
    x2 = x0; 
    y2 = y0;
    h2 = h0;
  }
  void display() {
    if (dist(mouseX, mouseY, x2, y2) < h2/2) {
      if (mousePressed && mouseButton==LEFT) {
        fill(255, 255, 0);
        x2 = mouseX;
        y2 = mouseY;
      } else if (mousePressed && mouseButton==RIGHT) {
        fill(255, 255, 0);
        angle2 = angle2 + 30;
        for(int i = 0;  i <= 100000000; i+=1){
		i= i + 1;}
        return;
      } else {
        fill(255, 0, 255);
      }
    } else {
      fill(0, 255, 0);
    }
    pushMatrix();
    translate(x2, y2);
    rotate(radians(angle2));
    beginShape();
    vertex(0, -sqrt(0.75*h2*h2));
    vertex(+0.5*h2, 0);
    vertex(0, sqrt(0.75*h2*h2));
    vertex(-0.5*h2,0);
    endShape(CLOSE);
    popMatrix();
  }
  
  void setXY(float x_, float y_) {
    x2=x_;
    y2=y_;
  }
  void incrementXY(float x_, float y_) {
    x2+=x_;
    y2+=y_;
  }
  PVector getPos() {
    return new PVector(x2+h2/2, y2+h2/2);
  }
  boolean over() {
    return mouseX>x2 && mouseX<x2+h2 && mouseY>y2 && mouseY<y2+h2;
  }
} 

class Tupat3 implements Node {  
  float x3;
  float y3;
  float h3;
  float angle3 = 0;
  Tupat3(float x0, float y0, float h0) {
    x3 = x0; 
    y3 = y0;
    h3 = h0;
  }
  void display() {
    if (dist(mouseX, mouseY, x3, y3) < h3/2) {
      if (mousePressed && mouseButton==LEFT) {
        fill(255, 255, 0);
        x3 = mouseX;
        y3 = mouseY;
      } else if (mousePressed && mouseButton==RIGHT) {
        fill(255, 255, 0);
        angle3 = angle3 + 30;
        for(int i = 0;  i <= 100000000; i+=1){
		i= i + 1;}
        return;
      } else {
        fill(255, 0, 255);
      }
    } else {
      fill(255, 0, 0);
    }
    pushMatrix();
    translate(x3, y3);
    rotate(radians(angle3));
    beginShape();
    vertex(0, -sqrt(0.75*h3*h3));
    vertex(+0.5*h3, 0);
    vertex(0, sqrt(0.75*h3*h3));
    vertex(-0.5*h3,0);
    endShape(CLOSE);
    popMatrix();
  }
  void setXY(float x_, float y_) {
    x3=x_;
    y3=y_;
  }
  void incrementXY(float x_, float y_) {
    x3+=x_;
    y3+=y_;
  }
  PVector getPos() {
    return new PVector(x3+h3/2, y3+h3/2);
  }
  boolean over() {
    return mouseX>x3 && mouseX<x3+h3 && mouseY>y3 && mouseY<y3+h3;
  }
}


</script>
<canvas></canvas>
</div>	
</div>
</section>
</body>
<footer>
<p> Copyright <i class="fa fa-copyright" aria-hidden="true"></i> Djukarna 2021</p>
<p> Open Source, silakan download dan modifikasi sendiri :)</p>
</footer>
</html>